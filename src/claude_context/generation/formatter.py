from datetime import datetime, timezone
from pathlib import Path

START_MARKER = "<!-- claude-context:start -->"
END_MARKER = "<!-- claude-context:end -->"


def generate_section(endpoints: dict[str, list[dict]], service_name: str) -> str:
    """Render the CLAUDE.md section from transformed endpoint data."""
    now = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    lines = [
        START_MARKER,
        "## API Consumers",
        f"> Auto-generated by claude-context â€” do not edit this section manually.",
        f"> Service: **{service_name}** | Last synced: {now}",
    ]

    for endpoint, callers in endpoints.items():
        count = len(callers)
        lines.append(f"\n### {endpoint}")
        lines.append(f"Called by {count} service{'s' if count != 1 else ''}:")

        for c in callers:
            parts = []

            if c["request_fields"]:
                fields = ", ".join(f"`{f}`" for f in c["request_fields"])
                parts.append(f"sends {fields}")
            if c["query_params"]:
                params = ", ".join(f"`{p}`" for p in c["query_params"])
                parts.append(f"query params: {params}")
            if c["request_headers"]:
                headers = ", ".join(f"`{h}`" for h in c["request_headers"])
                parts.append(f"custom headers: {headers}")
            if c["response_codes"]:
                codes = ", ".join(f"`{r}`" for r in sorted(c["response_codes"]))
                parts.append(f"responses: {codes}")

            last_seen = c["last_seen"][:10] if c["last_seen"] else "unknown"
            detail = "; ".join(parts) if parts else "no body observed"
            lines.append(
                f"- **{c['caller']}** ({c['call_count']:,} calls, last seen {last_seen}): {detail}"
            )

    lines.append(f"\n{END_MARKER}")
    return "\n".join(lines)


def update_claude_md(path: Path, section: str) -> None:
    """
    Write the generated section into CLAUDE.md.
    Replaces the existing marked section if present, otherwise appends.
    """
    existing = path.read_text(encoding="utf-8") if path.exists() else ""

    if START_MARKER in existing and END_MARKER in existing:
        start = existing.index(START_MARKER)
        end = existing.index(END_MARKER) + len(END_MARKER)
        updated = existing[:start] + section + existing[end:]
    else:
        separator = "\n\n" if existing.strip() else ""
        updated = existing.rstrip() + separator + section + "\n"

    path.write_text(updated, encoding="utf-8")
